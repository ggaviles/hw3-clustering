# Write your k-means unit tests here
# write tests for bfs
import random
import pytest
import pathlib
import sklearn.cluster
import numpy as np
from cluster import KMeans, utils

def test_empty():
    with pytest.raises(ValueError):
        mat, labels = utils.make_clusters(n=1000, m=0, k=3)
        kmeans = KMeans(k=3, tol=1e-6, max_iter=100)
        kmeans.fit(mat)
        kmeans.predict(mat)

def test_k_not_integer():
    with pytest.raises(TypeError):
        kmeans = KMeans(k=1e-6, tol=1e-6, max_iter=100)

def test_tol_not_float():
    with pytest.raises(TypeError):
        kmeans = KMeans(k=3, tol=0, max_iter=100)

def test_max_iter_not_float():
    with pytest.raises(TypeError):
        kmeans = KMeans(k=3, tol=1, max_iter=1e-6)

def test_if_k_is_zero():
    with pytest.raises(ValueError):
        kmeans = KMeans(k=0, tol=1e-6, max_iter=100)

def test_if_tol_is_zero():
    with pytest.raises(ValueError):
        kmeans = KMeans(k=3, tol=0.0, max_iter=100)

def test_if_max_iter_is_zero():
    with pytest.raises(ValueError):
        kmeans = KMeans(k=3, tol=1e-6, max_iter=0)

def test_correct_number_of_clusters():
    random_n = np.random.randint(1, 1000)
    random_k = np.random.randint(1, random_n)
    mat, labels = utils.make_clusters(n=random_n, m=2, k=random_k)
    kmeans = KMeans(random_k, tol=1e-6, max_iter=100)
    kmeans.fit(mat)
    kmeans.predict(mat)

    kmeans_sklearn = sklearn.cluster.KMeans(n_clusters=random_k, init='k-means++', n_init='auto', max_iter=100, tol=1e-6)
    kmeans_sklearn.fit(mat)
    kmeans_sklearn.predict(mat)
    assert len(kmeans.get_centroids()) == len(kmeans_sklearn.cluster_centers_)

def test_if_more_accurate_than_sklearn_kmeans():
    random_n = np.random.randint(1, 1000)  # Choose a random number n of observations
    random_k = np.random.randint(1, random_n)  # Choose a random number k up to n
    mat, labels = utils.make_clusters(n=random_n, m=2, k=random_k)
    kmeans = KMeans(random_k, tol=1e-6, max_iter=100)  # Instantiate a kmeans object from the class I wrote
    kmeans.fit(mat)  # Fit kmeans onto the data matrix mat
    my_generated_labels = kmeans.predict(mat)  # Generate labels for each data point

    # Repeat above steps using sklearn.cluster.Kmeans
    kmeans_sklearn = sklearn.cluster.KMeans(n_clusters=random_k, init='k-means++', n_init='auto', max_iter=100, tol=1e-6)
    kmeans_sklearn.fit(mat)
    kmeans_sklearn.predict(mat)

    # Labels generated by sklearn Kmeans algorithm
    # (I'm not sure why but label order was reversed when generated by sklearn
    # as compared to labels created by utils.make_clusters)
    sklearn_labels = kmeans_sklearn.labels_[::-1]

    # Calculate what percentage of values are the same in the labels array vs the generated labels
    similarity_percent_kmeans = np.mean(labels == my_generated_labels)
    similarity_percent_sklearn = np.mean(labels == sklearn_labels)

    # Assert that my_generated_labels are closer to the actual labels
    # ex: for n=1000, m=2, k=3, my similarity percent was 0.937, sklearn's was 0.861
    assert similarity_percent_kmeans > similarity_percent_sklearn






